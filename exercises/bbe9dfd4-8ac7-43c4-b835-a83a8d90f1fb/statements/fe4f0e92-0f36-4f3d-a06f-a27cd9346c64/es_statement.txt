<p>Como hemos se&ntilde;alado anteriormente, al hacer un <code>INSERT</code> en el que no se especifiquen los valores de todas las columnas, se obtendr&aacute; el valor <code>NULL</code> en aquellas columnas que no se han indicado. Por lo tanto, es obligatorio asignar un valor, al menos, a aquellas columnas que no pueden ser <code>NULL</code>.</p><h3>Ejemplo:</h3><p>En la siguiente sentencia no se ha especificado el valor de uno de los atributos que no puede ser <code><em>NULL</em></code>:</p><blockquote><pre><code>INSERT INTO employees(EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE)<br />VALUES (220, &#39;myLastName&#39;, &#39;email@juezlti.eu&#39;, CURRENT_DATE);</code><br /><strong><code>-- ERROR:  null value in column "job_id" of relation "employees" violates not-null constraint</code></strong></pre></blockquote><p>Deber&iacute;amos averiguar cu&aacute;les son los atributos que no pueden ser <code>NULL</code>. Para ello, podemos utilizar la sentencia <code>\d</code>.</p><blockquote><p><code>\d employees</code></p></blockquote><p>El anterior comando <code>psql</code> nos muestra los atributos de la tabla, de los que extraemos aquellos para los que no se permite el valor <code>NULL</code>.</p><blockquote><pre>                                               Table "public.employees"<br />     Column     |            Type             | Collation | Nullable |                    Default                     <br />----------------+-----------------------------+-----------+----------+------------------------------------------------<br /> employee_id    | integer                     |           | not null | nextval('employees_employee_id_seq'::regclass)<br /> first_name     | character varying(20)       |           |          | <br /> last_name      | character varying(25)       |           | not null | <br /> email          | character varying(25)       |           | not null | <br /> phone_number   | character varying(20)       |           |          | <br /> hire_date      | timestamp without time zone |           | not null | <br /> job_id         | character varying(10)       |           | not null | <br /> salary         | numeric(8,2)                |           |          | <br /> commission_pct | numeric(2,2)                |           |          | <br /> manager_id     | integer                     |           |          | <br /> department_id  | integer                     |           |          | </pre></blockquote><p>Podemos comprobar que nos faltar&iacute;a a&ntilde;adir el valor del atributo <code>JOB_ID</code>.</p><blockquote><pre><code>BEGIN;<br /><br /><strong>INSERT INTO employees(EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)<br />VALUES (220, &#39;Apellidos&#39;, &#39;email@juezlti.eu&#39;, CURRENT_DATE, &#39;IT_PROG&#39;);</strong><br />-- INSERT 0 1<br /><br />SELECT * FROM employees WHERE EMPLOYEE_ID = 220;<br />ROLLBACK;</code></pre></blockquote><h3>Ejercicio:</h3><p>A la siguiente sentencia le falta alg&uacute;n atributo obligatorio</p><blockquote><pre><code>INSERT INTO job_history(EMPLOYEE_ID, START_DATE, END_DATE, DEPARTMENT_ID)<br />VALUES (120, CURRENT_DATE - 730, CURRENT_DATE, 20);</code></pre></blockquote><p>A&ntilde;ade el atributo que falta para que la sentencia se ejecute correctamente. El valor del atributo puede ser cualquiera que cumpla con la restricci&oacute;n de integridad establecida sobre ese atributo.</p><small><p><strong>Nota:</strong> No olvides utilizar transacciones con <code>BEGIN;<code> y <code>ROLLBACK;<code> en tu entorno <code>PostgreSQL</code></p></small>